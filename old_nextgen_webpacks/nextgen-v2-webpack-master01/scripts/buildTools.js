/* eslint-disable import/no-extraneous-dependencies */
const fs = require('fs');

/**
 * Reads a template.ts file and returns the template as an object.
 * @param {string} projectName
 * @returns {{}}
 */
const extractToolsFromTemplate = (projectName) => {
  const path = `configs/${projectName}/template.ts`;
  const contents = fs.readFileSync(path, 'utf8');

  // Get variables used in imports
  const variableRegex = /(import) (?<variable>\w+) (from) '.+';/gi;
  const variableMatches = Array.from(contents.matchAll(variableRegex)).map((match) => match.groups.variable);

  // Remove variables from template strings
  const templateStringRegex = /\$\{\w+\}/g;
  let output = contents.replace(templateStringRegex, '');

  // Replace references to import variables with empty quotes.
  variableMatches.map((variable) => {
    output = output.replace(`: ${variable}`, `: ''`);
  });

  // Get everything after 'const template = '
  const templateObjectRegex = /(\{)(\n(.+)?)+(\})/gm;
  [output] = output.match(templateObjectRegex);

  // Turn the string into a node module and evaluate into an object
  // eslint-disable-next-line no-eval
  return eval(`module.exports = ${output}`);
};

/**
 * Recurse through an array of BlockConfig objects and return an array of
 * tools that have its `add` property set to `true`.
 * @param {Array<BlockConfig>} blockConfigs
 * @returns {Array<BlockConfig>}
 */
const getToolList = (blockConfigs) => {
  const allBlocksWithImport = [];
  blockConfigs.forEach((config) => {
    if (config.add) {
      if (config.name) allBlocksWithImport.push(config);
      if (config.toolbar && config.toolbar.items) allBlocksWithImport.push(...getToolList(config.toolbar.items));
      if (config.blocks) allBlocksWithImport.push(...getToolList(config.blocks));
      if (config.items) allBlocksWithImport.push(...getToolList(config.items));
    } else if (typeof config.add === 'undefined' && config.blocks) allBlocksWithImport.push(...getToolList(config.blocks));
    else if (config.items) allBlocksWithImport.push(...getToolList(config.items));
  });

  return allBlocksWithImport;
};

/**
 * Create the text to be written to the importedTools.ts file.
 * @param {string} projectName
 * @returns {string}
 */
const createImportedToolsText = (projectName) => {
  const projectTools = {};
  let txt = `/**
 * Components for ${projectName}.
 *
 * This file is dynamically generated by Webpack during the bundling process.
 */\n\n`;

  // Get template config based on projectName
  const { blocks } = extractToolsFromTemplate(projectName);
  const toolList = getToolList(blocks);

  // Create a list of required tools. An object is used for this instead of an array
  // so we don't create duplicates
  toolList.map((toolConfig) => {
    try {
      projectTools[toolConfig.name] = `./${toolConfig.import.replace(/\./g, '/')}`;
    } catch (e) {
      throw new Error(`Failed to import ${JSON.stringify(toolConfig.name, 4)}`);
    }
  });

  // Start building the output for the importedTools.ts file.
  // Create import declarations
  Object.keys(projectTools).map((toolName) => {
    const toolPath = projectTools[toolName];
    txt += `import { ${toolName} } from '${toolPath.replace(/\/js/g, '')}';\n`;
  });

  // Create export declaration
  txt += '\nexport const tools = {\n';

  Object.keys(projectTools).map((toolName) => {
    // tool name is prepended with two spaces to match the settings in .editorconfig
    txt += `  ${toolName},\n`;
  });

  txt += '};\n';

  return txt;
};

/**
 * Create and write the `importedTools.ts` file to disk.
 * @param {string} projectName
 * @returns {Promise<void>}
 */
const run = async (projectName) => {
  fs.writeFile('./src/importedTools.ts', createImportedToolsText(projectName), (err) => {
    if (err) throw err;
  });
};

/**
 * Determine if the given project uses any chart tools.
 * @param {string} projectName
 * @returns {boolean}
 */
const hasCharts = (projectName) => {
  // Get template config based on projectName
  const { blocks } = extractToolsFromTemplate(projectName);
  const toolList = getToolList(blocks);
  const toolNames = toolList.map((tools) => tools.name);
  return toolNames.includes('cChartContainer') || toolNames.includes('cGraphTool');
};

const hasAnalytics = (projectName) => {
  const { analytics } = extractToolsFromTemplate(projectName);
  return analytics;
};

module.exports = {
  run,
  hasCharts,
  hasAnalytics,
};
